<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/3.4.0/fabric.min.js"></script>
    <script src="./face-api.js"></script>
    <script src="https://unpkg.com/interactjs/dist/interact.min.js"></script>
    <!-- Compiled and minified CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">


    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <style>
        video {
            height: auto;
            width: 100%;
        }
        #zones .canvas {
            display: inline-block;
            border: 1px solid;
            overflow: hidden;
            position: relative;
            margin: 2px;
        }
        #buttons {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #zones .canvas .remove {
            width: 20px;
            height: 20px;
            font-size: 15px;
            position: absolute;
            top: 3px;
            right: 3px;
            cursor: pointer;
            line-height: 1.1;
            padding: 0;
            margin: 0;
        }
        #zones .canvas .remove i {
            font-size: 15px;
            line-height: 17px;
        }
        #zones canvas {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <nav>
        <div class="nav-wrapper">
            <span class="brand-logo center">
                <img src="https://mobidev.biz/wp-content/themes/MobiDev/images/media/logo.svg" alt="logo" style="width: 140px; height: 30px;"> Demo
            </span>
        </div>
    </nav>
    <br>
    <br>
    <br>
    <div id="modal" class="modal">
        <div class="modal-content">
            <h3>Detection models are loading, please wait</h3>
            <div class="progress">
                <div class="indeterminate"></div>
            </div>
        </div>
    </div>
    <div id="test" class="row" style="overflow: hidden; display: none">
        <div id="buttons">
            <button class="waves-effect waves-light btn-large capture-button">START WEBCAM</button>
            <button class="waves-effect waves-light btn-large start-with-upload red">START WITH UPLOAD</button>
            <input id="file-input" type="file" name="name" style="display: none;" accept="video/*"/>
        </div>
        <div class="col m6 s12">
            <video autoplay style="display: none"></video>
            <canvas id="canvas"></canvas>
        </div>
        <div id="zones" class="col m6 s12">

        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', main);

    function main() {

      const captureVideoButton = document.querySelector('#test .capture-button');
      const startWithUpload = document.querySelector('#test .start-with-upload');
      const buttonsContainer = document.querySelector('#buttons');
      const fileInput = document.querySelector('#file-input');
      const video = document.querySelector('#test video');
      const testContainer = document.querySelector('#test');
      const modal = document.querySelector('#modal');

      const modalBootstrapped = M.Modal.init(modal, {
        dismissible: false
      });

      modalBootstrapped.open();
      let modelsLoaded = false;

      const path = location.hostname === 'localhost' ? '/models' : '/capture_demo/models'
      Promise.all([
        // faceapi.nets.faceExpressionNet.loadFromUri(path),
        faceapi.nets.tinyFaceDetector.loadFromUri(path)
      ]).then(() => {
            modalBootstrapped.close();
            modelsLoaded = true;
            testContainer.style.display = 'block';
          }).catch(() => {
            modalBootstrapped.close();
            alert('something went wrong');
          });


      startWithUpload.onclick = function() {
        fileInput.click();
      }

      fileInput.addEventListener('change', e => {
        const target = e.target;
        if (target.files.length) {
          buttonsContainer.style.display = 'none';
          if (URL && URL.createObjectURL) {
            init(null, null, null, URL.createObjectURL(target.files[0]));
          } else {
            const reader = new FileReader();
            reader.onerror = function() {
              buttonsContainer.style.display = 'block';

              alert('something went wrong');
            };
            reader.onload = function (file) {
              const result = file.target.result;
              init(null, null, null, result);
            }
            reader.readAsDataURL(target.files[0]);
          }

        }
      });

  captureVideoButton.onclick = function() {
    buttonsContainer.style.display = 'none';
    navigator.mediaDevices.getUserMedia({
      video: true
    }).then(stream => {
      const tracks = stream.getTracks();
      if (!tracks.length) throw new Error('pew');

      init(null, null, stream);
    }).catch((e) => {
      console.log(e);
      alert('something went wrong')
    });
  };

      function init(width, height, stream, videoSrc) {
        if (stream) {
          video.srcObject = stream;
        } else {
          video.src = videoSrc;
        }
        video.addEventListener('loadeddata', () => {
          video.play();
          startLogic(width, height);
        });
      }

      function startLogic(width, height) {
        if (!width || !height) {
          video.style.display = 'block';
          const videoRect = video.getBoundingClientRect();
          const vRatio = video.videoWidth / video.videoHeight;
          width = videoRect.width;
          height = width / vRatio;
        }
        video.style.display = 'none';

        const canvas = document.querySelector('#canvas');
        canvas.setAttribute('width', width);
        canvas.setAttribute('height', height);
        video.setAttribute('width', width);
        video.setAttribute('height', height);

        video.style.width = width + 'px';
        video.style.height = height + 'px';

        const fabricCanvas = new fabric.Canvas(canvas, {
          width,
          height
        });

        const zones = document.querySelector('#zones');

        zones.addEventListener('click', (e) => {
          if (e.target.classList.contains('remove')) {
            e.preventDefault();
            if (e.target.parentNode._rect) {
              const _rect = e.target.parentNode._rect;
              fabricCanvas.remove(_rect);
              rects.splice(rects.indexOf(_rect), 1);
              e.target.parentNode.remove();
            }
          } else if (e.target.classList.contains('remove-icon')) {
            e.preventDefault();
            if (e.target.parentNode.parentNode._rect) {
              const _rect = e.target.parentNode.parentNode._rect;
              fabricCanvas.remove(_rect);
              rects.splice(rects.indexOf(_rect), 1);
              e.target.parentNode.parentNode.remove();
            }
          }
        })

        let initialPos, bounds, rect, dragging = false, isMoving = false;
        const options = {
          drawRect: false,
          onlyOne: false,
          rectProps: {
            stroke: 'red',
            strokeWidth: 1,
            fill: '',
            hasRotatingPoint : false,
            lockUniScaling: true
          }
        }

        window.rects = [];

        function onMouseDown(e) {
          dragging = true;
          initialPos = { ...e.pointer }
          bounds = {}
          if (isMoving) {
            isMoving = false;
            return;
          }
          if(options.drawRect && !isMoving){
            rect = new fabric.Rect({
              left: initialPos.x,
              top: initialPos.y,
              width: 0, height: 0,
              ...options.rectProps
            });
            fabricCanvas.add(rect)
            rects.push(rect);
          }
        }
        function update({pointer}) {
          if (initialPos.x > pointer.x) {
            bounds.x = Math.max(0, pointer.x)
            bounds.width = initialPos.x - bounds.x
          } else {
            bounds.x = initialPos.x
            bounds.width = pointer.x - initialPos.x
          }
          if (initialPos.y > pointer.y) {
            bounds.y = Math.max(0, pointer.y)
            bounds.height = initialPos.y - bounds.y
          } else {
            bounds.height = pointer.y - initialPos.y
            bounds.y = initialPos.y
          }
          if(options.drawRect && !isMoving){
            rect.left = bounds.x
            rect.top = bounds.y
            rect.width = bounds.width
            rect.height = bounds.height
            rect.dirty = true
            fabricCanvas.requestRenderAllBound()
          }
        }

        function onMouseMove(e) {
          if (!dragging && !isMoving) return;
          requestAnimationFrame(() => update(e))
        }

        function onMouseUp(e) {
          dragging = false;
          if (options.drawRect && rect && (rect.width == 0 || rect.height === 0)) {
            fabricCanvas.remove(rect)
          }
          if((!options.drawRect||!rect) && !isMoving){
            rect = new fabric.Rect({
              ...bounds, left: bounds.x, top: bounds.y,
              ...options.rectProps
            });
            fabricCanvas.add(rect)
            rects.push(rect);
            rect.dirty = true
            fabricCanvas.requestRenderAllBound()
          }
          isMoving = false;
          rect.setCoords()
        }
        function install() {
          fabricCanvas.on('mouse:down', onMouseDown);
          fabricCanvas.on('object:moving', () => {
            isMoving = true;
          });
          fabricCanvas.on('object:scaling', () => {
            isMoving = true;
          });
          fabricCanvas.on('object:rotating', () => {
            isMoving = true;
          });
          fabricCanvas.on('object:skewing', () => {
            isMoving = true;
          });
          fabricCanvas.on('mouse:move', onMouseMove);
          fabricCanvas.on('mouse:up', onMouseUp);
        }

        install();

        fabric.customBackground = fabric.util.createClass(fabric.Object, {
          render(ctx) {
            ctx.drawImage(video, 0,0, width, height);
          }
        });

        Object.assign(window, {
          _test: {
            fabricCanvas
          }
        })

        fabricCanvas.add(new fabric.customBackground());
        fabric.util.requestAnimFrame(function render() {
          fabricCanvas.renderAll();
          rects.forEach(r => {
            let canv;
            let append;
            const find = [...zones.querySelectorAll('.canvas')].find(c => c._rect === r);
            if (find) {
              append = find;
              canv = find.querySelector('canvas');
            } else {
              append = document.createElement('div');
              const remove = document.createElement('div');
              remove.innerHTML = '<i class="material-icons remove-icon">delete</i>';
              remove.setAttribute('class', 'remove btn-floating btn-large waves-effect waves-light red');
              append.appendChild(remove);
              append.classList.add('canvas');
              append.classList.add('js-resizable');
              append._rect = r;
              canv = document.createElement('canvas');
              append.appendChild(canv);
              interact(append).resizable({
                edges: { left: true, right: true, bottom: true, top: true },
                modifiers: [ interact.modifiers.aspectRatio({
                  ratio: 'preserve'
                })],
                listeners: {
                  move (event) {
                    const target = event.target
                    let x = (parseFloat(target.getAttribute('data-x')) || 0)
                    let y = (parseFloat(target.getAttribute('data-y')) || 0)

                    // update the element's style
                    target.style.width = event.rect.width + 'px'
                    target.style.height = event.rect.height + 'px'

                    // translate when resizing from top or left edges
                    x += event.deltaRect.left
                    y += event.deltaRect.top

                    target.setAttribute('data-x', x)
                    target.setAttribute('data-y', y)
                  }
                }
              });
            }
            const ctx = canv.getContext('2d');
            if (!append.hasAttribute('style')) {
              append.style.width = r.width * r.scaleX + 'px';
              append.style.height = r.height * r.scaleY + 'px';
            }
            canv.width = r.width * r.scaleX;
            canv.height = r.height * r.scaleY;
            const videoHeight = video.videoHeight;
            const videoWidth = video.videoWidth;
            const correctPosition = {
              width: videoWidth / width,
              height: videoHeight / height
            }
            ctx.drawImage(
              video,
              r.left * correctPosition.width,
              r.top * correctPosition.height,
              r.width * correctPosition.width * r.scaleX,
              r.height * correctPosition.height * r.scaleX,
              0,
              0,
              r.width * r.scaleX,
              r.height * r.scaleY);
            if (!find) {
              zones.appendChild(append)
            }
          })
          fabric.util.requestAnimFrame(render);
        });

        const faceRects = [];

        async function detect() {
          try {
            if (modelsLoaded) {
              const data = await faceapi.detectAllFaces(fabricCanvas.lowerCanvasEl, new faceapi.TinyFaceDetectorOptions());
              faceRects.forEach(i => fabricCanvas.remove(i));
              faceRects.length = 0;
              if (data.length) {
                data.forEach(({ box, imageDims }) => {
                  const realPosition = imageDims;
                  const correctPosition = {
                    width: realPosition.width / width,
                    height: realPosition.height / height
                  }
                  faceRects.push(new fabric.Rect({
                    left: box.x / correctPosition.width,
                    top: box.y / correctPosition.height,
                    width: box.width / correctPosition.width,
                    height: box.height / correctPosition.height,
                    stroke: 'blue',
                    strokeWidth: 3,
                    fill: '',
                    selectable: false,
                    hasRotatingPoint : false
                  }));
                  // const arr = expressions.asSortedArray();
                  // if (arr.length) {
                  //   faceRects.push(new fabric.Text(arr[0].expression, {
                  //     left: box.x / correctPosition.width + 4,
                  //     top: box.y / correctPosition.height + box.height / correctPosition.height,
                  //     fill: 'blue',
                  //     selectable: false,
                  //     centerRotation: false
                  //   }));
                  // }

                })
                faceRects.forEach(i => fabricCanvas.add(i));
                fabricCanvas.requestRenderAllBound()
              }
            }
          } catch (e) {
            console.log(e);
          } finally {
            await detect();
          }
        }

        const interval = setInterval(() => {
          if (modelsLoaded) {
            detect()
            clearInterval(interval);
          }
        }, 1000);
      }


    }
</script>
</body>
</html>
